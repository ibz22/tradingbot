import asyncio
import logging
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import time

logger = logging.getLogger(__name__)

class OrderSide(Enum):
    BUY = "buy"
    SELL = "sell"

class OrderType(Enum):
    MARKET = "market"
    LIMIT = "limit"

@dataclass
class TradeSignal:
    """Trading signal generated by a strategy"""
    token_mint: str
    side: OrderSide
    size_sol: float  # Size in SOL
    confidence: float  # 0.0 to 1.0
    strategy: str
    reason: str
    timestamp: float = field(default_factory=time.time)
    order_type: OrderType = OrderType.MARKET
    limit_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def is_valid(self) -> bool:
        """Check if signal is valid"""
        return (
            self.size_sol > 0 and
            0 <= self.confidence <= 1.0 and
            self.token_mint and
            self.strategy
        )

@dataclass
class StrategyConfig:
    """Base configuration for trading strategies"""
    enabled: bool = True
    max_position_size: float = 1.0  # Maximum position size in SOL
    min_trade_size: float = 0.01   # Minimum trade size in SOL
    confidence_threshold: float = 0.6  # Minimum confidence to trade
    max_trades_per_hour: int = 10
    cooldown_minutes: int = 5  # Cooldown between trades on same token
    
class BaseStrategy(ABC):
    """Base class for all trading strategies"""
    
    def __init__(self, name: str, config: StrategyConfig):
        self.name = name
        self.config = config
        self.enabled = config.enabled
        
        # State tracking
        self.last_trades: Dict[str, float] = {}  # token_mint -> timestamp
        self.trade_count_hour: int = 0
        self.last_hour_reset: float = time.time()
        
        # Dependencies (injected)
        self.price_feed = None
        self.technical_analyzer = None
        self.portfolio_manager = None
        self.risk_manager = None
        
    def set_dependencies(self, price_feed=None, technical_analyzer=None, 
                        portfolio_manager=None, risk_manager=None):
        """Inject dependencies"""
        self.price_feed = price_feed
        self.technical_analyzer = technical_analyzer
        self.portfolio_manager = portfolio_manager
        self.risk_manager = risk_manager
        
    @abstractmethod
    async def generate_signals(self, tokens: List[str]) -> List[TradeSignal]:
        """Generate trading signals for given tokens"""
        pass
    
    def can_trade(self, token_mint: str) -> bool:
        """Check if we can trade this token (rate limiting, cooldown)"""
        if not self.enabled:
            return False
            
        current_time = time.time()
        
        # Reset hourly trade count
        if current_time - self.last_hour_reset > 3600:
            self.trade_count_hour = 0
            self.last_hour_reset = current_time
            
        # Check hourly rate limit
        if self.trade_count_hour >= self.config.max_trades_per_hour:
            return False
            
        # Check cooldown for this specific token
        last_trade = self.last_trades.get(token_mint, 0)
        cooldown_seconds = self.config.cooldown_minutes * 60
        if current_time - last_trade < cooldown_seconds:
            return False
            
        return True
    
    def record_trade(self, token_mint: str):
        """Record that a trade was made"""
        current_time = time.time()
        self.last_trades[token_mint] = current_time
        self.trade_count_hour += 1
        
    def validate_signal(self, signal: TradeSignal) -> bool:
        """Validate a trading signal"""
        if not signal.is_valid():
            return False
            
        if signal.confidence < self.config.confidence_threshold:
            return False
            
        if signal.size_sol < self.config.min_trade_size:
            return False
            
        if signal.size_sol > self.config.max_position_size:
            return False
            
        if not self.can_trade(signal.token_mint):
            return False
            
        return True
    
    async def get_current_price(self, token_mint: str) -> Optional[float]:
        """Get current price for a token"""
        if not self.price_feed:
            return None
        price_data = self.price_feed.get_current_price(token_mint)
        return price_data.price if price_data else None
    
    def get_name(self) -> str:
        """Get strategy name"""
        return self.name
    
    def is_enabled(self) -> bool:
        """Check if strategy is enabled"""
        return self.enabled
    
    def enable(self):
        """Enable strategy"""
        self.enabled = True
        logger.info(f"Strategy {self.name} enabled")
        
    def disable(self):
        """Disable strategy"""
        self.enabled = False
        logger.info(f"Strategy {self.name} disabled")
        
    def get_stats(self) -> Dict[str, Any]:
        """Get strategy statistics"""
        current_time = time.time()
        return {
            "name": self.name,
            "enabled": self.enabled,
            "trades_last_hour": self.trade_count_hour,
            "max_trades_per_hour": self.config.max_trades_per_hour,
            "active_cooldowns": {
                token: int((self.config.cooldown_minutes * 60) - (current_time - timestamp))
                for token, timestamp in self.last_trades.items()
                if current_time - timestamp < (self.config.cooldown_minutes * 60)
            },
            "config": {
                "max_position_size": self.config.max_position_size,
                "min_trade_size": self.config.min_trade_size,
                "confidence_threshold": self.config.confidence_threshold,
                "cooldown_minutes": self.config.cooldown_minutes
            }
        }